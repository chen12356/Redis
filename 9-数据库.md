### 数据库

#### 1.1 服务器的数据库

​	`Redis`将所有的数据库都保存在服务器状态`redsi.h/redisServer `结构的`db`数组中，而`db`数组的每个项都是一个`redis.h/redidDb`结构，每个`redisDb`结构代表一个数据库：
​		![image-20200918135022452](.\imges\image-20200918135022452.png)

![image-20200918135203605](.\imges\image-20200918135203605.png)

总体的结构：![image-20200918135245292](.\imges\image-20200918135245292.png)

#### 1.2 切换数据库

​		每个`redis`客户端都有自己的目标数据库，默认时`da[0]` 0号数据库， 用于通过`select num`命令直接切换到指定`num号`的数据库(`0<= num <16`)
![image-20200918135746682](.\imges\image-20200918135746682.png)

​		`select`命令实现：通过修改`redisClient.db`指针，让该指针指向服务器中不同的数据库，从而实现切换目标数据库的功能。

**注意：** 谨慎处理多数据程序，因为目前为止(3.0)，仍然**没有可以返回客户端目标数据的命令**，如果不是用`redis-cli`（该命令执行，会在旁边显示数据库编号），那么我们切换数据库久的话，容易忘记正处于那个数据库中，，**最好**在执行`select 目标数据库编号` ,**确保**显示以切换，否则如果不小心删除了别库的数据就比较麻烦了。

#### 1.3 数据库键空间

​		`Redis`是一个键值对(`key-value`) 的数据库服务器， 每个数据库都是由一个`redis.h/redisDb`结构表示，其中`redisDb`结构的**`dict`字典**保存了数据库中所有键值对，我们称之为：**键空间(key space)**：	
![image-20200918140722315](.\imges\image-20200918140722315.png)

比如下图：
		![image-20200918140958644](.\imges\image-20200918140958644.png)

![image-20200918141122758](.\imges\image-20200918141122758.png)

##### 1.3.1 添加新键

​		实际上：将一个新的键值对添加到 键空间字典里面，其中键为字符串对象，值是任意一种类型`redis`对象。比如：添加了 字符串date

```
redis> set date "2013.12.1"
ok
```

![image-20200918141722972](.\imges\image-20200918141722972.png)

##### 1.3.2 删除键

​		将键空间里面删除指定键所对应的键值对对象

```
redis> del book   #删除 book键--> 会删除键空间里的book键对应的哈希对象
(integer) 1
```

![image-20200918142057167](.\imges\image-20200918142057167.png)

##### 1.3.3 更新键

​		更新数据操作，将键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的方式也会有所不同的。

```
#值对象是个字符串对象
redis> set message "blah blah"  #更新message的值
ok
```

![image-20200918142354857](.\imges\image-20200918142354857.png)

```
#值对象是个哈希对象
redis> hset book page 320  #更新book键，这里往book键加了内容
ok
```

![image-20200918142648969](.\imges\image-20200918142648969.png)

##### 1.3.4 对键取值

​		在键空间中取出键所对应的值对象，根据值对象的类型不同，取值的方法也是有所不同的。

```
redis> get message   #获取键为 message的值对象 以图（9-4）为目前状态
'hello world'
```

`get`命令执行流程：1、在键空间中查找`message`这个键；2、找到之后接着去该键所对应的字符串对象值；3、之后再返回值对象中包含的字符串`hello world`，图9-9所示
	![image-20200918143253002](.\imges\image-20200918143253002.png)

```
redis> lrange alphabet 0 -1  #获取键为alphabet
1)"a"
2)"b"
3)"c"
```

`lrange`命令首先键空间中查找键`alphabet`，找到键之后接着取该键对应的列表对象值，然后再返回列表对象中包含的三个字符串对象的值。图9-10所示。
	![image-20200918143751152](.\imges\image-20200918143751152.png)

##### 1.3.5 其他键空间操作

​		比如：`flushdb`命令，就是删除键空间中所有的键值对来实现的。
​					`randomkey`命令，就是从键空间中随机返回一个键来实现的。
​		还有，用于返回**数据库键数量**的`dbsize`命令，以及`exists`**判断键在不在**、`rename`、`keys`等命令，都是操作 键空间 来实现的。

##### 1.3.6 读写键空间时的维护操作

​		当使用`Redis`命令对数据库进行读写时，服务器不仅会对键空间执行读写操作，还会执行一些额外的维护操作，其中包括：

+ 在读取一个键之后，服务器会根据键是否存在进行记录两个值，**命中次数(hit)、不命中次数(miss)**，该两个值可以通过命令`info stats`的结果：`keyspace_hits`属性和`keyspace_misses`属性查看。
+ 在读取一个键之后，服务器会**更新键的`lru`(最后一次使用)时间**，主要可以**计算键的闲置时间，**可以通过`object idletime key_name`  命令查看，key_name键的闲置时间。
+ 读取一个键，服务器**发现该键过期**了，那么会**先删除这个键**，然后再执行其他操作(后面详细介绍)
+ 如果客户端**使用`watch` 命令监视某个键**，服务器在对这个监视的键进行**修改之后**，那么该键会被标记为**脏(dirty)**，从而让事务程序注意到这个键已经被修改(后面讲事务会详细)
+ 服务器**每次修改**一个键之后，都会对**脏(dirty)键计数器的值增1，**这个计数器会触发服务器的持久化以及复制操作。
+ 如果服务器开启的**数据库通知功能**，那么在对键进行修改时，服务器会按配置发送相应的数据库通知。

#### 1.4 键的生存时间/过期时间

​		通过`expire`命令或者`pexpire`命令，客户端可以设置以秒或者毫秒精度为数据库中的某个键设置生存时间(`time to live,TTL`)，再经过指定的时间后，服务器会自动删除生存时间为0 的键：
​		![image-20200918151635766](.\imges\image-20200918151635766.png)

注意：针对只能用于字符串键的一个命令：`setex`命令，原理和`expire`命令是一样的。

​		另外还有个过期时间，通过`expireat`或者`pexpireat`命令，设置某个键的过期时间(expire time)。过期时间是个 `unix`时间戳，当键的过期时间来临时，服务器会自动删除该键：

​			![image-20200918152251905](.\imges\image-20200918152251905.png)

​			![image-20200918152343718](.\imges\image-20200918152343718.png)

​	如何**查看键的过期时间**？

​			使用`ttl `或者`pttl`命令接收一个带有生存时间或者过期时间的键，那么该命令返回的结果就是剩余的生存时间，也就是说剩下多久时间服务器就会将其删除：
​			![image-20200918152958789](.\imges\image-20200918152958789.png)

##### 1.4.1 设置过期时间

​		上面介绍了，过期时间方法有四种，虽然有多种不同的单位或者不同形式来设置命令，底层中是**：`expire`、`pexpire`、`expireat`这三个命令是使用 `pexpireat`命令来实现的**。因为前三者命令得到的参数，再经过转换之后，都是基于`pexpireat`命令实现。如下图：
​	![image-20200918153627017](.\imges\image-20200918153627017.png)

##### 1.4.2 保存过期时间

​		`redisDb`结构中存在`expires`字典保存了数据库中所有键的过期时间，称为 **过期字典**
​		很简单：
​					过期字典的**键 是个指针**，指向的是键空间的指定的键对象(数据库中的键)
​					过期字典的**值是个`long long`类型的整数**，保存了键所指向数据库键的过期时间(毫秒精度的`unix`时间戳)

![image-20200918154751690](.\imges\image-20200918154751690.png)

##### 1.4.3 移除过期时间

​	`persist`命令可以移除一个键得过期时间：
​			![image-20200918155126516](.\imges\image-20200918155126516.png)

​	底层实现：`persist`命令是在过期字典中 **查找到键**，然后**解除键和值**(过期时间)在过期字典的关联。
​		上图中，使用`persist`命令之后，那么**过期字典中就消失了 对应message的键值对**

`persist`伪代码：

```PYTHON
def PERSIST(key):
    if key not in redisDb.expires:  #判断key是否存在过期字典中
        return 0
    redisDb.expires.remove(key)  #存在的话，把过期字典中的这个key 移除了
    return -1
```

##### 1.4.5 计算并返回剩余的过期时间

​		`ttl`命令**以 `秒`为单位**返回 键的剩余生存时间，`pttl`是**以 `毫秒`的单位**返回键的剩余时间：

![image-20200918160345944](.\imges\image-20200918160345944.png)

​		这两个命令，是通过**计算键的过期时间和当前时间之间的差**来实现的。
`pttl`伪代码：

```python
def PTTL(key):
    if key not in redisDb.dict:  #首先判断下键在不在数据库
        return -2
    expire_time_in_ms = redisDb.expire.get(key) #从过期字典中获取指定key的时间，取不到为None
    
    if expire_time_in_ms is None: #说明没有设置过期时间
        return -1
    now_ms = get_current_unix_timestamp_in_ms() #获取当前的时间
    
    return (expire_time_in_ms - now_ms) #做差，得到pttl的结果 剩余的毫秒的过期时间
```

`ttl`伪代码

```python
def TTL(key):
    ttl_in_ms = PTTL(key)  #直接调用 PTTL函数，就得到的 毫秒单位的剩余时间，转换成秒即可
    
    if ttl_in_ms < 0:
        #说明是pttl返回了 -2或者-1 
        return ttl_in_ms  
    return ms_to_sec(ttl_in_ms)  #直接把毫秒转换成秒
```

##### 1.4.5 过期键的判定

​		通过过期字典，程序可以用一下步骤**检查一个给定键是否过期**：
​				1、检查给定**键是否存在过期字典**中：存在，取过期时间
​				2、检查当前`unix`时间戳**是否大于键的过期时间**：如果大于，那么键过期，否则未过期。

​		伪代码实现

```python
def is_expired(key):
    expire_time_in_ms = redisDb.expires.get(key) #从过期字典取值
    if expire_time_in_ms is None:
        return False  #没有设置过期时间，根本不过期
    now_ms = et_current_unix_timestamp_in_ms()  #获取当前的时间
    if now_ms > expire_time_in_ms: #判断当前时间是否大于过期时间
        return True  #说明过期
    return False  #没有过期
```

比下图：
![image-20200918164548213](.\imges\image-20200918164548213.png)

![image-20200918164609298](.\imges\image-20200918164609298.png)

**注意：**

​		实现**过期键的判定的另一种方法**使用`ttl`或者`pttl`命令，比如对某个键执行`ttl`命令，并且命令返回的值大于等于 0，说明该键未过期。但是在实际应用中，`Redis`检查键是否过期的方法和 `is_expired`函数所描述的方法一致的，因为**直接访问字典比执行一个命令稍微快一些**。

#### 1.5 过期删除策略

​	如果一个键过期了，那是什么时候删除的呢？有三种不同的策略：`定时删除、惰性删除、定期删除`。

##### 1.5.1 定时删除

+ 简要：在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即对键执行删除操作。
+ 优点：**对内存是最友好**的；保证过期键会尽快的被删除，释放过期键占用的内存。
+ 缺点：**对CPU是最不友好**的，如果过期键比较多的话，那么创建定时器与删除的这一操作下，会大大的影响性能；在时间比较紧张的情况下，`将CPU时间用在删除键上和当前任务没关系的过期键上`，无疑是对服务器的**响应时间和吞吐量造成不良影响**。

##### 1.5.2 惰性删除

+ 简要：**放任过期键不管**，当后期获取该键的时候，判断是否过期了，如果是就删除。

+ 优点：**对CPU时间是最友好的**；只会在取出键的时候才对键进行检查，如果某个键过期了，不是非删不可的话，CPU是不会再花时间去删除其它无关紧要的过期键。
+ 缺点：**对内存是最不友好的**；如果过期键非常多，而后期又没有用到，那么会**永久的保存在数据库**中，除非你清空数据库，这样会殃及其它有用的数据。

##### 1.5.3 定期删除

+ 简要：**每隔一段时间**，对数据做一次检查，删除过期键。至于要删除多少过期键，由算法决定。
+ 优点：限制了删除操作执行的**时长和频率来减少**对CPU时间的影响，另一方面也有效的减少了因为过期键带来的内存浪费。
+ 缺点：**不好确定删除操作执行的时长和频率**：
      如果删除操作**执行的太频繁**，或者执行时间间隔太短，那么可能会把定期变成了定时。
      如果删除执行的**操作太少**的话，或者执行时间间隔太长，那么可能会把定期类似于惰性删除一样，浪费内存的情况。
  所以，服务器必须根据情况，合理的设置删除操作的执行时长和执行效率。

#### 1.6 `Redis`的过期删除策略

​	`Redis`服务器使用的 `惰性删除`和`定期删除`两种策略：通过配合使用这两种删除策略，服务器可以很好的使用CPU时间和避免浪费内存之间取得平衡。

##### 1.6.1 惰性删除策略的实现

所有读写数据库的`redis`命令在执行之前都会**调用`db.c/expireIfNeeded`函数**对输入键进行检查：

​		1、如果输入键过期，那么会调用函数`expireIfNeeded`把输入键从数据库中删除了；

​		2、如果输入键没有过期，那么`expireIfNeeded`函数不作任何动作。

​		下图是`expireIfNeeded`函数的过程：**相当于一个过滤器**，它在命令真正的执行前过滤掉过期键，从而避免命令接触到过期键。

![](.\imges\image-20200921140952979.png)

​		另外，因为每个被访问的键都可能因为过期而被`expireIfNeeded`函数删除，所以每个命令的实现函数都是**必须同时处理键存在和不存在的两种情况**：

​		1、键存在时，命令按照键存在的情况执行。

​		2、键不存在时，同理。

​		下图时一个完整 `get`命令流程：

![image-20200921142231630](.\imges\image-20200921142231630.png)

##### 1.6.2 定期删除策略的实现

​		过期键的定期删除策略由**`redis.c/activaExpireCycle`函数**实现，每当`Redis`的服务器周期性操作`redis.c/serverCron`函数执行时，`activaExpireCycle`函数就会被调用，**在规定的时间内**，**分多次遍历服务器中的各个数据库**，从数据库的`expires`字典随机检查一**部分键**的过期时间，并删除其中的过期键。

`activaExpireCycle`伪代码实现：

```python
定期删除策略的伪代码实现：

#默认每次检查的数据库数量
DEFAULT_DB_NUMBERS = 16

#默认每个数据库检查的键数量
DEFAULT_KEY_NUMBERS = 20

#全局变量，记录检查进度
current_db = 0

def activaExpireCycle():
    
    #初始化要检查数据库数量
    #如果服务器上的数据库数量比 默认值要小，则按照服务器上标准
    if server.dbnum < DEFAULT_DB_NUMBERS:
        db_numbers = server.dbnum
    else:
        db_numbers = DEFAULT_DB_NUMBERS
     
    #进行遍历数据库
    for i in range(db_numbers):
        
        #查看进度，是否等于服务器数据库的数量，是的话，说明遍历了服务器的所有数据库一次
        #然后再把current_db重置为0，重新开始
        if current_db == server.dbnum:
            current_db = 0
        #获取当前要处理的数据库
        redisDb = server.db[current_db]
        
        #将数据库的索引指向下一个数据库
        current_db += 1
        
        #检查数据库键
        for j in range(DEFAULT_KEY_NUMBERS):
            
            #如果库中没有一个是带过期时间的键，那么直接跳过这个数据库
            if redisDb.expire.size() == 0:
                break
                
            #随机去一个存在过期时间的键
            key_with_ttl = redisDb.expires.get_random_key()
            
            #检查键是否过期，是的话直接删除
            if is_expire(key_with_tt1):
                delete_key(key_with_ttl)
                
            #已达到时间上线，停止处理
            if reach_time_limit():
                return

```

函数每次运行，都从**一定数量的数据库**中取出**一定数量的随机键**进行检查，并删除其中的过期键；

#### 1.7 `AOF、ROB` 和复制功能对过期键的处理

​	下面介绍的是过期键在其它模块是如何处理的

##### 1.7.1 生成`RDB`文件

​	在执行`save`或者`bgsave`命令时，创建一个新的`RDB`文件，会对数据库中的**键作检查**，已过期的键是**不会被保存**到新创建的`RDB`文件中；
​	因此，数据库中包含过期键，不会对生成新的`RDB`文件造成影响。

##### 1.7.2 载入`RDB`文件

​	在`Redis`服务器中，如果开启了`RDB`功能，那么对`RDB`文件载：

​			1、如果以**主服务器模式运行**，在载入`RDB`文件时，会对文件中保存的键进行过滤，**不会将过期的键写入到服务器**中。

​			2、如果以**从服务器模式运行**，在载入`RDB`文件时，会将文件里**所有的而数据载入到从服务器**中，但进行主从同步时，从服务器的数据会被清空，所以一般来说，过期键对 载入`RDB`文件的从服务器不会造成影响。

##### 1.7.3 `AOF`文件写入

​	当服务器以`AOF`持久化模式运行时，如果存在的过期键没有被惰性删除或者定期删除的话，那么`AOF`文件不会因为这个过期键而产生任何影响。

​	当过期键被惰性删除或者定期**删除之后**，程序会向`AOF`文件**追加(`append`)一条`DEL`命令**，来显示的记录这个过期键已经被删除了。

```
比如：
客户端使用  get message 命令，查询这个键，发现这个键已经过期了，那么服务器存在 3个操作：
	1、从数据库中删除这个键
	2、追加一条 del message 命令到 AOF 文件中
	3、向执行的 get 命令的客户端返回 空回复
```

##### 1.7.4 `AOF`重写

​	和上面介绍的`生成RDB文件时`类似，在执行`AOF`重写的过程中，会对数据库中的键进行检查，**已经过期的键是不会保存到重写后的`AOF`文件中。**

##### 1.7.5 复制

​	当服务器运行在**复制模式**下时，从服务器的过期键删除动作**由主服务器控制**：

​	1、主服务器在删除一个过期键之后，会向其它所有的从服务器发送一个`DEL`命令，告知从服务器删除这个过期键。

​	2、从服务器在执行客户端的读写命令时，如果遇到了过期键，那么**从服务器会当作这个键没过期一样，去处理这个键**。

​	3、从服务器只有在接到主服务器发送的`DEL`才会删除这个过期键。

​	通过主服务器来控制从服务器的过期键，这样一来可以**保证主从服务器数据的一致性。**

#### 1.8 数据库通知

​	该功能是`Redis 2.8版本`新增加的，可以让客户端通过订阅给定的频道或模式，来获悉数据库中键的变化，以及数据库中命令的执行情况。

+ **键空间通知**：查看某个键执行了什么命令

![image-20200921164040108](.\imges\image-20200921164040108.png)

![image-20200921164152932](.\imges\image-20200921164152932.png)

+ **键事件通知**：某个命令被什么键执行了；

  ![image-20200921164643370](.\imges\image-20200921164643370.png)

### 总结

![image-20200921165437855](.\imges\image-20200921165437855.png)