### 数据库

#### 1.1 服务器的数据库

​	`Redis`将所有的数据库都保存在服务器状态`redsi.h/redisServer `结构的`db`数组中，而`db`数组的每个项都是一个`redis.h/redidDb`结构，每个`redisDb`结构代表一个数据库：
​		![image-20200918135022452](.\imges\image-20200918135022452.png)

![image-20200918135203605](.\imges\image-20200918135203605.png)

总体的结构：![image-20200918135245292](.\imges\image-20200918135245292.png)

#### 1.2 切换数据库

​		每个`redis`客户端都有自己的目标数据库，默认时`da[0]` 0号数据库， 用于通过`select num`命令直接切换到指定`num号`的数据库(`0<= num <16`)
![image-20200918135746682](.\imges\image-20200918135746682.png)

​		`select`命令实现：通过修改`redisClient.db`指针，让该指针指向服务器中不同的数据库，从而实现切换目标数据库的功能。

**注意：** 谨慎处理多数据程序，因为目前为止(3.0)，仍然**没有可以返回客户端目标数据的命令**，如果不是用`redis-cli`（该命令执行，会在旁边显示数据库编号），那么我们切换数据库久的话，容易忘记正处于那个数据库中，，**最好**在执行`select 目标数据库编号` ,**确保**显示以切换，否则如果不小心删除了别库的数据就比较麻烦了。

#### 1.3 数据库键空间

​		`Redis`是一个键值对(`key-value`) 的数据库服务器， 每个数据库都是由一个`redis.h/redisDb`结构表示，其中`redisDb`结构的**`dict`字典**保存了数据库中所有键值对，我们称之为：**键空间(key space)**：	
![image-20200918140722315](.\imges\image-20200918140722315.png)

比如下图：
		![image-20200918140958644](.\imges\image-20200918140958644.png)

![image-20200918141122758](.\imges\image-20200918141122758.png)

##### 1.3.1 添加新键

​		实际上：将一个新的键值对添加到 键空间字典里面，其中键为字符串对象，值是任意一种类型`redis`对象。比如：添加了 字符串date

```
redis> set date "2013.12.1"
ok
```

![image-20200918141722972](.\imges\image-20200918141722972.png)

##### 1.3.2 删除键

​		将键空间里面删除指定键所对应的键值对对象

```
redis> del book   #删除 book键--> 会删除键空间里的book键对应的哈希对象
(integer) 1
```

![image-20200918142057167](.\imges\image-20200918142057167.png)

##### 1.3.3 更新键

​		更新数据操作，将键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的方式也会有所不同的。

```
#值对象是个字符串对象
redis> set message "blah blah"  #更新message的值
ok
```

![image-20200918142354857](.\imges\image-20200918142354857.png)

```
#值对象是个哈希对象
redis> hset book page 320  #更新book键，这里往book键加了内容
ok
```

![image-20200918142648969](.\imges\image-20200918142648969.png)

##### 1.3.4 对键取值

​		在键空间中取出键所对应的值对象，根据值对象的类型不同，取值的方法也是有所不同的。

```
redis> get message   #获取键为 message的值对象 以图（9-4）为目前状态
'hello world'
```

`get`命令执行流程：1、在键空间中查找`message`这个键；2、找到之后接着去该键所对应的字符串对象值；3、之后再返回值对象中包含的字符串`hello world`，图9-9所示
	![image-20200918143253002](.\imges\image-20200918143253002.png)

```
redis> lrange alphabet 0 -1  #获取键为alphabet
1)"a"
2)"b"
3)"c"
```

`lrange`命令首先键空间中查找键`alphabet`，找到键之后接着取该键对应的列表对象值，然后再返回列表对象中包含的三个字符串对象的值。图9-10所示。
	![image-20200918143751152](.\imges\image-20200918143751152.png)

##### 1.3.5 其他键空间操作

​		比如：`flushdb`命令，就是删除键空间中所有的键值对来实现的。
​					`randomkey`命令，就是从键空间中随机返回一个键来实现的。
​		还有，用于返回**数据库键数量**的`dbsize`命令，以及`exists`**判断键在不在**、`rename`、`keys`等命令，都是操作 键空间 来实现的。

##### 1.3.6 读写键空间时的维护操作

​		当使用`Redis`命令对数据库进行读写时，服务器不仅会对键空间执行读写操作，还会执行一些额外的维护操作，其中包括：

+ 在读取一个键之后，服务器会根据键是否存在进行记录两个值，**命中次数(hit)、不命中次数(miss)**，该两个值可以通过命令`info stats`的结果：`keyspace_hits`属性和`keyspace_misses`属性查看。
+ 在读取一个键之后，服务器会**更新键的`lru`(最后一次使用)时间**，主要可以**计算键的闲置时间，**可以通过`object idletime key_name`  命令查看，key_name键的闲置时间。
+ 读取一个键，服务器**发现该键过期**了，那么会**先删除这个键**，然后再执行其他操作(后面详细介绍)
+ 如果客户端**使用`watch` 命令监视某个键**，服务器在对这个监视的键进行**修改之后**，那么该键会被标记为**脏(dirty)**，从而让事务程序注意到这个键已经被修改(后面讲事务会详细)
+ 服务器**每次修改**一个键之后，都会对**脏(dirty)键计数器的值增1，**这个计数器会触发服务器的持久化以及复制操作。
+ 如果服务器开启的**数据库通知功能**，那么在对键进行修改时，服务器会按配置发送相应的数据库通知。

#### 1.4 键的生存时间/过期时间

​		通过`expire`命令或者`pexpire`命令，客户端可以设置以秒或者毫秒精度为数据库中的某个键设置生存时间(`time to live,TTL`)，再经过指定的时间后，服务器会自动删除生存时间为0 的键：
​		![image-20200918151635766](.\imges\image-20200918151635766.png)

注意：针对只能用于字符串键的一个命令：`setex`命令，原理和`expire`命令是一样的。

​		另外还有个过期时间，通过`expireat`或者`pexpireat`命令，设置某个键的过期时间(expire time)。过期时间是个 `unix`时间戳，当键的过期时间来临时，服务器会自动删除该键：

​			![image-20200918152251905](.\imges\image-20200918152251905.png)

​			![image-20200918152343718](.\imges\image-20200918152343718.png)

​	如何**查看键的过期时间**？

​			使用`ttl `或者`pttl`命令接收一个带有生存时间或者过期时间的键，那么该命令返回的结果就是剩余的生存时间，也就是说剩下多久时间服务器就会将其删除：
​			![image-20200918152958789](.\imges\image-20200918152958789.png)

##### 1.4.1 设置过期时间

​		上面介绍了，过期时间方法有四种，虽然有多种不同的单位或者不同形式来设置命令，底层中是**：`expire`、`pexpire`、`expireat`这三个命令是使用 `pexpireat`命令来实现的**。因为前三者命令得到的参数，再经过转换之后，都是基于`pexpireat`命令实现。如下图：
​	![image-20200918153627017](.\imges\image-20200918153627017.png)

##### 1.4.2 保存过期时间

​		`redisDb`结构中存在`expires`字典保存了数据库中所有键的过期时间，称为 **过期字典**
​		很简单：
​					过期字典的**键 是个指针**，指向的是键空间的指定的键对象(数据库中的键)
​					过期字典的**值是个`long long`类型的整数**，保存了键所指向数据库键的过期时间(毫秒精度的`unix`时间戳)

![image-20200918154751690](.\imges\image-20200918154751690.png)

##### 1.4.3 移除过期时间

​	`persist`命令可以移除一个键得过期时间：
​			![image-20200918155126516](.\imges\image-20200918155126516.png)

​	底层实现：`persist`命令是在过期字典中 **查找到键**，然后**解除键和值**(过期时间)在过期字典的关联。
​		上图中，使用`persist`命令之后，那么**过期字典中就消失了 对应message的键值对**

`persist`伪代码：

```PYTHON
def PERSIST(key):
    if key not in redisDb.expires:  #判断key是否存在过期字典中
        return 0
    redisDb.expires.remove(key)  #存在的话，把过期字典中的这个key 移除了
    return -1
```

##### 1.4.5 计算并返回剩余的过期时间

​		`ttl`命令**以 `秒`为单位**返回 键的剩余生存时间，`pttl`是**以 `毫秒`的单位**返回键的剩余时间：

![image-20200918160345944](.\imges\image-20200918160345944.png)

​		这两个命令，是通过**计算键的过期时间和当前时间之间的差**来实现的。
`pttl`伪代码：

```python
def PTTL(key):
    if key not in redisDb.dict:  #首先判断下键在不在数据库
        return -2
    expire_time_in_ms = redisDb.expire.get(key) #从过期字典中获取指定key的时间，取不到为None
    
    if expire_time_in_ms is None: #说明没有设置过期时间
        return -1
    now_ms = get_current_unix_timestamp_in_ms() #获取当前的时间
    
    return (expire_time_in_ms - now_ms) #做差，得到pttl的结果 剩余的毫秒的过期时间
```

`ttl`伪代码

```python
def TTL(key):
    ttl_in_ms = PTTL(key)  #直接调用 PTTL函数，就得到的 毫秒单位的剩余时间，转换成秒即可
    
    if ttl_in_ms < 0:
        #说明是pttl返回了 -2或者-1 
        return ttl_in_ms  
    return ms_to_sec(ttl_in_ms)  #直接把毫秒转换成秒
```

#### 1.5 过期键的判定

​		通过过期字典，程序可以用一下步骤**检查一个给定键是否过期**：
​				1、检查给定**键是否存在过期字典**中：存在，取过期时间
​				2、检查当前`unix`时间戳**是否大于键的过期时间**：如果大于，那么键过期，否则未过期。

​		伪代码实现

```python
def is_expired(key):
    expire_time_in_ms = redisDb.expires.get(key) #从过期字典取值
    if expire_time_in_ms is None:
        return False  #没有设置过期时间，根本不过期
    now_ms = et_current_unix_timestamp_in_ms()  #获取当前的时间
    if now_ms > expire_time_in_ms: #判断当前时间是否大于过期时间
        return True  #说明过期
    return False  #没有过期
```

比下图：
![image-20200918164548213](.\imges\image-20200918164548213.png)

![image-20200918164609298](.\imges\image-20200918164609298.png)

**注意：**

​		实现**过期键的判定的另一种方法**使用`ttl`或者`pttl`命令，比如对某个键执行`ttl`命令，并且命令返回的值大于等于 0，说明该键未过期。但是在实际应用中，`Redis`检查键是否过期的方法和 `is_expired`函数所描述的方法一致的，因为**直接访问字典比执行一个命令稍微快一些**。