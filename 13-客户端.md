### 一、客户端

#### 1、简要

​	`Redis`服务器时典型的**一对多服务器**程序：一个服务器可以与多个客户端建立网络连接，每个客户端都可以向服务器发起命令请求，服务器也会对这些请求命令进行回复。

​	通过`IO多路复用技术`实现文件事件处理器，`Redis`服务器使用**单线程单进程的方式**来处理命令请求，并与多个客户端进行网络通信。

​	每个与服务器进行连接的客户端，服务器都会为这些客户端**建立相应的`redis.h/redisClient`结构(客户端状态)**，这个结构保存了客户端当前的状态信息，以及执行相关功能需要用到的数据结构，其中包括：

![image-20201010133002929](.\imges\image-20201010133002929.png)

​	**`Redis` 服务器 状态 结构的 `clients`属性是一个链表，**该链表保存了所有与服务器连接的**客户端状态结构**，对客户执行批量操作，或者查找某个指定客户端，都可以通过**遍历`clients链表`**来完成：

![image-20201010133525468](.\imges\image-20201010133525468.png)

#### 2、客户端属性

客户端状态包含的属性可以**分为两类**：

+ 一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到的属性
+ 另一类是和特定功能相关的属性，比如执行事务时需要用到的`mstate`属性等。

##### 2.1 套接字描述符

​	客户端状态的 `fd`属性记录了客户端正在使用的套接字描述符

根据客户端类型不同： `fd` 属性的值 可以是 **-1 或者大于 -1 的整数**

+  伪客户端 --> -1
  + 目前`Redis`中用到的伪客户端地方：用于载入`AOF`文件并还原数据库状态、执行`Lua`脚本中包含的`redis命令`
+ 普通客户端  --> 大于 -1 

 `CLIENT list`  命令可以查看 fd的值

![image-20201010135126378](.\imges\image-20201010135126378.png)

##### 2.2 名字

​	默认情况下，客户端连接到服务器上，该客户端是没有名字的：、

![image-20201010135357991](.\imges\image-20201010135357991.png)

​	为客户端设置名字

![image-20201010135557892](.\imges\image-20201010135557892.png)

**注意：**如果客户端有名字的话，那么name会**指向一个字符串对象**，该对象保存的客户端的名字，否则的话，name属性**指向的NULL**

##### 2.3 标志

客户端的标志属性`flags`记录了**客户端的角色(role)，以及客户端目前所处的状态**： 

*int 类型*

其中 `flags`属性的值可以是单个标志：`flags = <flags>`；

也可以是多个标志的二进制或，比如：`flags = <flag1> | <flag2>|..`

![image-20201010140645908](.\imges\image-20201010140645908.png)

![image-20201010140908137](.\imges\image-20201010140908137.png)

![image-20201010141415747](.\imges\image-20201010141415747.png)

![image-20201010141507279](.\imges\image-20201010141507279.png)

![image-20201010141606513](.\imges\image-20201010141606513.png)

##### 2.4  输入缓冲区

 用于保存客户端发送的命令请求：

![image-20201010141735090](.\imges\image-20201010141735090.png)

比如： `set key value`  执行该命令

![image-20201010141814912](.\imges\image-20201010141814912.png)



输入缓冲区的大小会**根据输入内容动态地缩小或者扩大**，但它的最大**不能超过1GB**，否则服务器就关闭这个客户端。

![image-20201010141911951](.\imges\image-20201010141911951.png)

##### 2.5 命令与命令参数

​	服务器会将客户端发起地请求命令保存到 `querybuf`属性之后，服务器会对请求内容分析，并得出命令参数以及参数个数，分别保存到客户端状态的`argv和argc 属性中`

![image-20201010142856501](.\imges\image-20201010142856501.png)

![image-20201010143209871](.\imges\image-20201010143209871.png)

##### 2.6 命令的实现函数

​	当服务器从协议内容中分析并得出`argv和argc`属性的值之后，服务器将根据项`agrv[0]`的值，在命令表中**查找命令**所**对应的命令实现函数**

![image-20201012101932814](.\imges\image-20201012101932814.png)

![image-20201012102033697](.\imges\image-20201012102033697.png)

##### 2.7 输出缓冲区

​	执行命令**所得的命令回复**会被保存在客户端状态的输出缓冲区里面，每个客户端都有**两个输出缓冲区**可用，一个缓冲区的大小是固定的，另一个缓冲区大小是可变的：

+ 固定大小：用于保存那些**长度比较小**的回复，比如 ok、简短的字符串值、整数值、错误回复等；
+ 可变大小：用于保存那些**长度比较大**的回复，比如 一个非常长的字符串，列表等

客户端的**固定大小**缓冲区由**`buf和bufpos`** 两个属性组成：

![image-20201012105744055](.\imges\image-20201012105744055.png)

![image-20201012105936775](.\imges\image-20201012105936775.png)

##### 2.8 身份验证

​	客户端状态的**`authenticated`**属性用于记录客户端是否通过了身份验证。

+ 当`authenticated`的值**为0**，那么表示客户端未通过身份验证；
  + 未通过验证的，除了`auth`命令外，客户端发的任何其他命令会被**拒绝执行**。

+ 当`authenticated`的值**为 1**，那么表示客户端已经通过身份验证；
  + 通过验证，可以执行任何命令，和往常一样正常使用。

注意：如果服务器**没有启用**身份验证功能的话，那么即使`authenticated`属性为 **0 (默认值)**的话，服务器也不会拒绝执行客户端发送的命令请求。

##### 2.9 时间

下列是关于时间的属性：

![image-20201026133356614](.\imges\image-20201026133356614.png)

#### 3、客户端的创建与关闭

##### 3.1 创建普通客户端

​	如何客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用`connect函数`连接到服务器时，服务器就会**调用连接事件处理器**，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构**clients链表的末尾。**

例子：假设当前c1、c2两个普通客户端正在连接服务器，那么当一个新的谱图客户端c3连接到服务器之后，会将c3体添加到`clients`链表的末尾：

![image-20201026135514473](.\imges\image-20201026135514473.png)

##### 3.2 关闭普通客户端

普通客户端**被关闭的多种原因**：

+ 当客户端进程退出或者被杀死；
+ 客户端发送**不符合协议格式**的命令请求；
+ 客户端成为了 `client kill` 命令的目标；
+ 如果服务器设置了**timeout** 配置，那么客户端的空转时间超过了timeout的值；如果此时存在一个特殊的比如主从过程中备份、还有开通订阅等命令的话，即使超过这个值的话，客户端是不会关闭的。
+ 客户端发送的命令请求的大小**超过**了输入缓冲区的限制大小(**默认为1GB**)；
+ 如果要发送给客户端的**命令回复的大小超过**了输出缓冲区的限制大小：
  + 可变大小的缓冲区由一个链表和任意多个字符串对象组成，**理论上**是可以保存任意长度的命令回复，但是**为了避免客户端回复过大，占用太多服务器资源**，还是会检查输出缓冲区的大小，如果大小超过范围的话，**执行相应的限制操作**：
    + 通过两种模式来限制客户端输出缓冲区的大小：
      + 硬性限制( hard limit) ：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器会立即关闭客户端
      + 软性限制( soft limit) ：如果输出缓冲区的大小超过了软性限制所设置的大小，但是还没有超过硬性限制，那么服务器会记录客户端到达软性限制的起始时间；之后服务器会继续监视，如果输出缓冲区大小一直超过软性限制，并且时间超了，那么该客户端会被关闭。如果在指定时间范围内，不在超过软性限制的话，那么就不会被关闭。
    
    ![image-20201027094410644](.\imges\image-20201027094410644.png)

##### 3.3 Lua脚本的伪客户端

​	服务器会在初始化时创建负责执行`Lua脚本`中包含的`Redis`命令的客户端，并将这个伪客户端关联在服务器状态结构的`lua_client`属性中：

![image-20201027100408154](.\imges\image-20201027100408154.png)

##### 3.5 `AOF`文件的伪客户端

​	服务器在载入`AOF`文件时，会创建用于执行`AOF`文件的包含的`Redis`命令的伪客户端，当文件载入完成后，会关闭这个伪客户端。

### 二、总结

![image-20201027100854848](.\imges\image-20201027100854848.png)

![image-20201027101127682](.\imges\image-20201027101127682.png)