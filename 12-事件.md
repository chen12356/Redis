### 一、事件

+ **简要**
  + `Redis`服务器是一个事件驱动程序，需要处理两类事件：
    + **文件事件(file event)**：服务器通过**套接字与客户端**(其它`Redis`服务器)进行连接，而**`文件事件就是服务器对套接字操作的抽象`**。它们之间通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
    + **时间时间(time event)**：服务器中一些操作(比如serverCron函数)需要在给定时间点执行，而**`时间事件就是服务器对这类定时操作的抽象`**。

### 二、文件事件

​	`Redis`是基于`Reactor模式`(反应器模式)开发自己的网络事件处理器：该处理器都称为`文件处理器(file event handler)`:

+ 利用`I/O多路复用` 来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
+ 当被监听的套接字准备好执行`连接应答(accept)、读取(read)、写入(write)、关闭(close)`等操作时，相应的文件事件就会产生，这是文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

文件处理器：即**实现了高性能的网络通信模型**，又可以很好地与`Redis`服务器中其他同样以单线程方式运行地模块进行对对接，着保持了`Redis`内部单线程设计的简单性。

#### 2.1 文件事件处理器的构成

​	四个组成部分：`套接字`、`I/O多路复用`、`文件事件分派器`、`事件处理器`

![image-20200930135006631](.\image-20200930135006631.png)

其中：`I/O多路复用` 会将所产生事件的套接字都放到一个**队列**中，通过这个队列，**`按照有序、同步、每次一个套接字的方式向文件事件分派器传送套接字`**。当上一个套接字产生的事件被处理完毕之后，`IO多路复用`程序才会继续向文件分派器传送下一个套接字。

![image-20200930135359989](.\imges\image-20200930135359989.png)

#### 2.2 `I/O多路复用`程序的实现

​	`Redis`中存在常见的多路复用函数库：`select`、`epoll`、`evport`、`kqueue`；通过这些函数库实现多路复用程序。

​	`Redis`为每个IO多路复用函数库都实现相同的API，所以IO多路复用程序的底层实现是可以互换的。

![image-20200930140014082](.\imges\image-20200930140014082.png)

​	**注意**：程序在编译时，**会自动选择系统中性能最高**的`I/O多路复用函数库`来作为`Redis`的多路复用程序的底层实现。

#### 2.3 事件类型

​	多路复用程序可以监听多个套接字的`ae.h/AE_READABLR`事件和`ae.h/AE_WRITABLE`事件，这**两类事件和 套接字的对应关系**如下：

+ 当套接字变得**可读**时(也就是客户端对套接字执行write、close)，或者有**新的可应答套接字出现**时(也就是客户端对服务器进行connect)，那么套接字会产生`AE_READABLE事件`

+ 当套接字变得 **可写**时(也就是客户端对套接字执行read)，套接字会产生`AE_WRITABLE`事件。

如果同一个套接字同时产生了**两个事件**，那么文件处理器**会优先处理 读套接字(`AE_READABLE`)，后处理 写套接字(`AE_WRITABLE`)**

#### 2.4 文件事件的处理器

+ **连接应答处理器**：为了对连接服务器的各个客户端进行应答。
+ **命令请求处理器**：为了接收客户端传来的命令请求。
+ **命令回复处理器**：为了向客户端返回命令的执行结果。
+ **复制处理器**：当主服务器和从服务器进行复制操作时。

以上常用的处理器就是前三者。

**客户端和服务器的整个通信工程**如下图：

![image-20201009091133379](.\imges\image-20201009091133379.png)

### 三、时间事件

​	`Redis`的时间事件分为以下**两类**：

+ **定时事件**：让一段程序在**指定的时间之后执行一次**。比如，x程序在当前时间的30毫秒之后执行一次。
+ **周期性时间**：让一段程序在**每隔指定时间就执行一次**。比如，x程序每隔30毫秒执行一次。

时间事件由**三个属性组成**：如下

+ `id` ：服务器会为时间事件创建全局唯一ID(标识号)。**ID按从小到大的顺序递增**，新事件比旧事件的大(另外新的插入在表头)
+ `when` ：毫秒精度的时间戳，记录时间事件的到达(arrive)时间。
+ `timeProc` ：时间事件处理器，一个函数。当时间到达时，服务器就**会调用相应处理器来处理事件**。

![image-20201009104019398](.\imges\image-20201009104019398.png)

**时间事件处理器的返回值**：

+ **返回一个非`AE_NOMORE`的整数值**,说明这个事件为为周期性时间：如果时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的`when`属性进行更新，让这个事件在一段时间再次到达，并以这种方式一直更新运行下去。
+ 否则为定期时间；

#### 3.1 实现

​	服务器会将**所有的时间事件**都放在一个**无序链表**中，每当时间事件执行器运行时，它就**遍历整个链表**，查找**所有已到达的时间事件**，并**调用相应的事件处理器**。

![image-20201009104447274](.\imges\image-20201009104447274.png)

#### 3.2 `API`

+ `ae.c/aeCreateTimeEvent函数`

  + 参数分别为：**毫秒数**ms、时间**事件处理器**proc
  + 作用：将一个新的时间事件**添加到服务器**，这个新的时间事件将在当前事件的ms毫秒之后到达，而事件处理器为proc。

+ `ae.c/aeDeleteFileEvent函数`

  + 参数：时间事件的ID
  + 作用：从服务器中的时间事件的链表中**删除指定ID的事件**。

+ `ae.c/aeSearchNearestTimer函数`

  + 参数：无
  + 作用：返回到达时间距离当前时间**最接近的那个时间事件**。

+ `ae.c/processTimeEvents函数`

  + 参数：无

  + 作用：时间事件的执行器，会**遍历所有**已到达的时间事件，并调用这些事件的处理器。其中已到达，指的是时间事件的`when`属性记录的时间戳**等于或小于**当前的时间戳。

  + **伪代码实现**

    ```python
    def processTimeEvent():
        
        #遍历服务器的所有时间事件
        for time_event in all_time_event():
            
            #检测事件时间是否已经到达
            if time_event.when <= unix_ts_now():
                
                #事件已到达
                #执行事件处理器，并获取返回值
                retval = time_event.timeProc()
                
                #如果这是一个定时事件
                if retval == AE_NOMRE:
                    #那么将该事件从服务器中删除
                    delete_time_event_from_server(time_event)
                
                #否则是一个周期性事件
                else:
                    # 那么需要按照事件处理返回值作为更新时间事件的 when 属性
                    update_when(time_envet,retval)
    ```


#### 3.3 时间事件应用实例：`serverCron函数`

​	持续运行的`Redis`服务器需要定期的检测和调整自身的资源、状态，确保服务器可以长期、稳定的运行。而定期操作是通过`redis.c/serverCron函数`负责运行，下面列举该函数所完成工作有：

+ 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等
+ 清理数据库中的过期时间键值对
+ 关闭和清理连接失效的客户端
+ 尝试进行`AOF`或`RDB`持久化操作
+ 如果服务器时主服务器，那么会对从服务器进行定期同步
+ 如果处于集群模式，对集群进行定期同步和连接测试

`Redis`服务器以  周期性事件  的方式来运行`serverCron函数`，在服务器运行期间，每隔一段时间，serverCron就好被执行一次，直到服务器关闭为止。

​	在2.6版本那会，该函数每秒运行10次。

​	在2.8开始，用户可以修改hz选项来调整该函数每秒执行次数，(redis.conf)

### 四、事件的调度与执行

​	服务器中存在两种类型事件(文件、时间)，所以服务器需要对这两种事件进行调度，决定何时应该处理文件事件、何时处理时间事件，以及花多少时间来处理它们等。

​	`Redis`中，事件的调度和执行由`ae.c/aeProcessEvents`函数负责:

伪代码：

```python
def aeProcessEvents():
    
    #获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    
    #计算最接近的时间事件距离到达时间多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    
    #如果事件已到达，那么remaind_ms 的值可能是负数将该值设为0
    if remaind_ms < 0:
        remaind_ms = 0
    
    #根据remaind_ms的值，创建 timeval 结构
    timeval = create_timeval_with_ms(remaind_ms)
    
    #阻塞并等待文件事件产生，最大阻塞时间由传入的timeval 结构决定
    #如果remaind_ms 的值为0，那么aeApipoll调用之后马上返回，不阻塞
    aeApipoll(timeval)
    
	#处理所有已产生的文件事件
    processFileEvents()
    
    #处理所有已到达的时间事件
	processTimeEvents()

```

**注意：**在伪代码中，写了`processFileEvents()`函数，是不存在的，虚构的，主要是讲述方便一些。在实际中，处理已产生文件事件的代码时直接写在`aeProcessEvents`函数里面。

##### 4.1`Redis`主函数

将`aeProcessEvents`函数置于一个循环中，加上**初始化和清理函数**，那么就构成了`Redis服务器的主函数`:

```python
#redis服务器的主函数伪代码

def main():
    
    #初始化服务器
    init_server()
	
    #一直处理事件，直到服务器为止
    while server_is_not_shutdown():
        aeProcessEvents()
    
    #服务器关闭，执行清理操作
    clean_server()
    
```



从事件的角度来看，**`Redis`服务器的运行流程**如下图：

![image-20201010102052340](.\imges\image-20201010102052340.png)

##### 4.2 事件的调度和执行规则

![image-20201010102616850](.\imges\image-20201010102616850.png)

![image-20201010102816139](.\imges\image-20201010102816139.png)

### 五、总结

![image-20201010103008570](.\imges\image-20201010103008570.png)