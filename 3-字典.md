### 字典

+ 简要：又称为符号表、关联数组、映射，是一种用于保存键值对的抽象数据结构。

![image-20200911144733107](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911144733107.png)

![image-20200911144809570](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911144809570.png)

### 二、字典的实现

+ **简要：**`Redis`的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典的一个键值对。

+ **哈希表**

  + `Redis`字典所使用的哈希表由 `dict.h/dictht`结构定义：

    ![image-20200911145711738](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911145711738.png)

    重新声明下：每个`dictEntry`结构保存着一个键值对。
    					还有 `sizemask = size -1`

  + 比如下图 一个大小为 4 的空哈希表(没有包含任何键值对)

    ​		![image-20200911150012067](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911150012067.png)

+ **哈希表节点**

  + 使用`dictEntry`结构表示，上面说了，每一个 `dictEntry`结构都保存着一个键值对：

    ![image-20200911150844023](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911150844023.png)

  + 将两个索引值相同的 键连接在一起：

    ![image-20200911151138450](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911151138450.png)

+ **字典**

  + `Redis`中字典有`dict.h/dict`结构表示

    ![image-20200911152323845](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911152323845.png)

    补充：`ht` 该属性是包含两项的数组，数组中每一项都是一个 dictht 哈希表，一般情况下，字典只使用 `ht[0]`哈希表，而`ht[1]`哈希表只会对`ht[0]`哈希表进行 `rehash`(重散列，下面会介绍)时使用

  + 普通的字典

    ![image-20200911152927673](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911152927673.png)

### 三、哈希算法

+ **简要：**当要将一个新的键值对添加到字典里面时，需要先根据键值对的键计算出哈希值和索引值，然后在根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面即可。

+ `Redis`计算哈希值与索引值的方法：

  ```
  #使用字典设置的： 哈希函数，计算key的哈希值
  hash = dict -> type  -> hashFunction(key); #得到哈希值
  
  #使用哈希表的 sizemask属性和哈希值，计算出索引值
  #根据不同情况，ht[x] 可以时ht[0]或者ht[1]
  index = hash & dict -> ht[x].sizemask;  #其中& 位运算（相同位为1的值为1，否在为0）
  
  补充 & (位运算)
  &是位运算符号的一种，“与”运算符号，即当两个被操作数换算成二进制后的相同位同时为1时，结果为1，否则为0。
  所以8&3 等价于 1000&0011
  	其结果为0:
  		1000
  		0011
  		_____
  		0000
  ```

  + 比如：将一个 键值对 k0 和 v0 添加到字典里面，程序时如何运行的？

    ![image-20200911155015154](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200911155015154.png)

    ![image-20200911155649932](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911155649932.png)

    补充：如果又插入一个新的键值对k1和v1，如果计算出索引值也是0，那么会通过`dicEntry`的`next`属性指向另一个哈希表节点的指针，所以：k1和v1会接在k0和v0的位置后面，(上面图存在可看)

### 四、解决键冲突

+ **简要：**当有**两个或以上**数量的键被分配到了哈希表数组的**同一个索引上面**时，称这些键发生了**冲突**(collision)

+ 解决方法

  + **链地址法：**上面介绍了，每个哈希表节点都有一个 `next`指针，多个哈希表节点可以用 `next指针`组成一个**单向链表**，被分配到**同一个索引上**的多个节点用这个单向链表连接起来，---> 这样就解决了键冲突的问题。

  + 注意：因为`dictEntry`节点组成的链表没有指向链表表尾的指针(根本不知道表尾指针)，所以为了速度考虑，`Redis`在处理时：将新节点添加到链表的头部(表头位置）这样做`时间复杂度O(1)`，**排在其他已有节点的前面** ；否则要计算尾部指针那么时间复杂度就为 O(n)了。

  + 例子：将 键值对 k2和v2插入到哈希表中

    ![image-20200911161713987](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911161713987.png)

    ![image-20200911161851298](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911161851298.png)

### 五、rehash(重散列)

+ **目的：**为了哈希表的负载因子维持在一个合理的范围之内。

+ **需求：**哈希表在不断扩大或者缩小，我们需要对哈希表的大小进行相应的扩展与收缩。通过 `rehash`来完成

+ **简要：**指的是重新计算**键**的`哈希值和索引值`，然后将键值对放置到`ht[1]`哈希表的指定位置上。

+ `Redis`如何对哈希表进行 `rehash`的操作：

  ```
  由于ht是个数组，存在两项数组，每项数组都是dictEntry哈希表
  1、首先为字典 ht[1]分配表空间，分配机制？
  	大小取决于要执行的操作，以及ht[0]中键值对数量(ht[0].used)
  	分两种情况：
  		扩展操作：  ht[1]的大小 = 第一个大于等于ht[0].used*2 的2^n(2的n次方幂)；
  		收缩操作：  ht[1]的大小 = 第一个大于等于ht[0].used  的 2^n
  2、将保存在ht[0]中的所有键值对rehash到ht[1]上面。
  3、当ht[0]中所有都迁移到了ht[1]之后(ht[0]此时为空)，释放ht[0],将ht[1]设置为ht[0],然后在ht[1]上在创建一个空便哈希表，作为下一此 rehash操作做准备。
  ```

+ 例子：将ht[0]进行扩展操作

  ![image-20200911164848218](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911164848218.png)

  ![image-20200911165305709](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911165305709.png)
  ![image-20200911165556009](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911165556009.png)
  ![image-20200911170136664](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200911170136664.png)
  
+ **自动进行收缩扩展** 

  ​	``负载因子 = 哈希表已保存键值对(ht[0].used) / 哈希表大小(ht[0].size)`

  + 服务器没有执行`BGSAVE`或`BGREWIRTEAOF`命令，并且负载因子大于等于 1 .
  + 服务器正在执行`BGSAVE`或`BGREWIRTEAOF`命令，并且负载因子大于等于 5 .
  + 哈希表的负载因子 小于 0.1时，自动开始哈希表的**收缩操作。**

  ​        **问题1：**为什么有无执行`BGSAVE`或`BGREWIRTEAOF`命令，得到的负载因子却不同？

  ​	         	`Redis`在执行该命令的时候，fork函数会开启一个子进程，而大多数的系统都采用`写时复制(copy-on-write)`技术来优化子进程的使用效率。所以当存在子进程期间，**服务器会提高**执行扩展操作所需要的负载因子，从而尽可能避免**子进程存在时**进行哈希表扩展，可以避免不必要内存写入，最大限度的节约内存。

  ​		**问题2：**什么是写时复制？

  ​					`写时复制(copy-on-write)` ：首fork为我们创建一个子进程，和父进程几乎是相同，此时需要将父进程的除了正文段之外几乎所有的数据拷贝到子进程中(如`堆，栈，数据段`)  -----》 导致了创建 子进程的过程 很慢。 从而引出 写时复制来提高创建子进程过程。写时复制 不会拷贝任何数据，和进程共享一份数据，`仅当父进程或自己需要对这份数据进行写入时，才会为子进程分配物理空间`。

  ​		**问题3：**为什么子进程存在期间进行哈希扩展，会`造成不必要内存写入操作`？

  ​				     由于知道了什么是写时复制操作，当服务器在执行`BGSAVE`或`BGREWIRTEAOF`命令时，创建新的子进程，此时如果我们扩展了哈希表，那么相当于`往 父进程 中写入数据`，同时又会`导致 子进程 复制父进程`的操作。造成不必要内存写入。

  **注意**：`负载因子过大，空间利用率高了，那么时间利用率比较大` (`时间换空间`)  -->不建议过大，

### 六、渐变式 rehash

+ **简要：**扩展和收缩操作哈希表，是将ht[0]上的所有键值对都rehash到ht[1]上。注意：这个rehash动作并不是一次性的，集中式的，而是**分而治之，渐进式**的完成的。

+ **问题：**如果键值对就 几个，几十个，那么服务器可以瞬间完成rehash。如果有上百万、千万级别甚至更多，如果一次性rehash的话，那么服务器会在一段时间停止服务。

  ​		为了避免这种情况发生，服务器是渐变式rehash，分多次将ht[0]里面的键值对慢慢的rehash到ht[1]上。

+ **具体步骤：**

  + 为`ht[1]`分配空间，让字典同时持有 `ht[0]`和`ht[1]`两个哈希表
  + 字典中维持一个索引计数器` rehashidx`，开始时，`值为0`，表示工作开始。
  + 在`rehash`期间，每次对字典进行`增删改查`时，程序还会`顺带将rehashidx索引上`的所有键值对`rehash到ht[1]`上，另外 `rehashidx的值加 1`
  + 当全部键值对都rehash到ht[1]上，`rehashidx的值设为-1`，表示rehash操作完成。

+ **补充：**

  + 在渐变式rehash过程中，字典会`同时查询 `两个哈希表 `ht[0]`、`ht[1]`。假设时查询操作，那么会在ht[0]中查询，如果没有会在ht[1]上查询。但是如果时**插入操作**的话，`一律保存`在`ht[1]`表上，这样保证了`ht[0]表只减不增	`。最终ht[0]变成空表。

### 七、字典`API`

![image-20200914104332194](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200914104332194.png)

![image-20200914104351027](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200914104351027.png)

### 八、总结

![image-20200914104531528](C:\Users\Administrator\Desktop\Redis详解\imges\image-20200914104531528.png)