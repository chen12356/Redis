### 一、类型检查与命令多态

#### 1.1 简要

​		`Redis`中用于**操作键的命令**基本可以分为 `两种类型`

##### 1.1.1 任何类型的键可执行

​		其中**一种命令可以对任何类型的键执行**，比如：`del、expire、rename、type、object`等这些命令。如下例子利用`del`命令，来删除三种不同类型的键：

```
# 字符串键
127.0.0.1:6379> set msg "hello"
OK

# 列表键
127.0.0.1:6379> rpush number 1 2 3 4
(integer) 4

# 集合键
127.0.0.1:6379> sadd fruits apple banana cherry
(integer) 3

# 删除以上类型的键
127.0.0.1:6379> del msg
(integer) 1
127.0.0.1:6379> del number 
(integer) 1
127.0.0.1:6379> del fruits
(integer) 1
```

##### 1.1.2 特定类型的键可执行

**另一种命令只能对特定类型的键执行**，比如：

+ `set、get、append、strlen`等命令只能对字符串键执行；
+ `hset、hget、hdel、hlen`等命令只能对哈希键执行；
+ `rpush、lpop、linsert、llen`等命令只能对列表键执行；
+ `sadd、spop、sinter、scard`等命令只能对集合键执行；
+ `zadd、zcard、zrank、zscore`等命令只能对有序集合键执行；

![image-20200917161642466](.\imges\image-20200917161642466.png)

#### 1.2 类型检查的实现

​		为了确保只有指定类型的键可以执行某些特定的命令，`Redis`在执行一个命令之前，会**先检查输入键的值对象的类型是否正确**，然后再决定是否执行特定命令。下图是`llen`命令在执行命令的类型检查过程：(其底层是**：`通过redisObject结构的type属性来实现的`)**

![image-20200917161801656](.\imges\image-20200917161801656.png)

#### 1.3 多态命令的实现

​	`Redis`除了会根据**`值对象的类型`**来判断是否执行指定命令之外，，还会根据**`值对象的编码`**，选择正确的命令实现代码来执行命令的。

​	比如：介绍`列表对象`时，它有两种编码方式：`ziplist`或者`linkedlist`

​		当我们调用`llen`命令执行的时候，`Redis`除了要确保执行命令的时列表键之外，还会根据**列表键的值对象编码**方式来正确的使用`llen`命令：

​		1、如果列表对象使用`ziplist`编码，说明是**压缩列表**实现的，那么程序会调用`ziplistLen`函数来实现`llen`命令；

​		2、如果列表对象使用`linkedlist`编码方式，说明是**双端链表**实现的，同理，程序会调用`listLength`函数来实现`llen`命令；		

​		借用**面向对象方面得术语**来说，我们可以认为`llen`命令是**多态**，只要执行了`llen`命令得是列表键，那么无论值对象使用的是`ziplist`或者`linkedlist`编码，命令都是可以正常执行的。

​		实际上，多态可以分两种，一是基于**类型的多态**(一个命令可以同时用于处理多种不同类型的键)； 二是基于**编码的多态**(一个命令可以同时用于处理多种不同的编码)

​		下图是 `llen`命令的执行过程：![image-20200918091723821](.\imges\image-20200918091723821.png)

### 二、内存回收

​		**C语言 不具备自动内存回收功能**，所以`Redis`在自己的对象系统中构建了一个**`引用计数`**技术来实现内存回收机制，通过这一机制，程序可以**跟踪对象的引用**信息，在适当的时候**自动释放对象**并进行内存回收。

​		每个对象的引用技术信息由`redisObject`结构的`refcount`属性记录：

​		![image-20200918092523570](.\imges\image-20200918092523570.png)

​		对象的引用技术信息会随着对象的使用不断的发生变化b：

​		1、在**新建一个对象**时，引用计数的值会被**初始化为 1**；
​		2、当被新程序调用之后，该值会**增加 1**；
​		3、当对象**不再被一个程序使用**时，该值会减 1；
​		4、当对象的**引用计数值为 0** 时，对象所占用的内存会被释放。

​		对象的整个周期的划分：`创建对象、操作对象、释放对象`三个对象；下图时整个过程：

​				![image-20200918102109337](.\imges\image-20200918102109337.png)

### 三、对象共享

​		除了用于实现引用计数内存回收机制之外，对象的引用计数属性话带有 **`对象共享`** 作用。

假设：键A创建了整数值100的字符串对象作为值对象，如下图：

​			![image-20200918102448721](.\imges\image-20200918102448721.png)
​		此时，键 B也要创建一个同样保存了整数值 100 的字符串对象作为值对象。那么服务器的做法有两种：

​		1、为键B **新建**一个包含整数值100的字符串对象；

​		2、让键A 和 键B **共享同一个字符串对象**；

​		上面两种方法，明显时`第2种更加节约内存`。
​		**实现第 2 种方法**的需要两个步骤：

​				首先，将数据库键的`值指针指向一个现有的值对象`；
​				其次，将被共享的`值对象的引用计数 加 1` 。
​		![image-20200918103217842](.\imges\image-20200918103217842.png)
​			上图实现了对象共享，可以发现`refcount`的值为2，其它属性没有任何变化，这对**节约内存有很大帮助**。
​			`Redis`中，初始化服务器时，`会创建1万个字符串对象`，包含`0到9999`的所有整数值，当用到这些字符串对象时，服务器会**使用这些共享对象，而不会新建对象**。
​		另外，**创建共享字符串对象的数量可以通过修改**`redis.h/REDIS_SHARED_INTEGERS`常量来修改。

下图是共享了`redis`初始化创建的共享字符串对象：
![image-20200918104459037](.\imges\image-20200918104459037.png)

**需要注意：**

​		这些共享对象不单单只有字符串键可以使用，那些数据结构中**嵌套了字符串对象的对象**(比如`linkedlist`编码的对象，`hashtable`编码的哈希对象，`hashtable`编码的集合对象，以及`zset`编码的有序集合对象)都是可以用到这些共享对象的。

​		**疑问：**为什么`Redis`不共享包含字符串的对象？

​		**解答：**想哈，如果共享包含字符串的对象的话，程序要去检查给定的共享对象和键想要的创建的目标字符串是不是完全相同，当时一个共享字符串的**保存的值越复杂，那么检查验证的过程中时间复制度会越高**，消耗的cpu时间也就越高。

​		 比如：如果共享对象时**保存整数值**的字符串对象，那么验证操作的复杂度`O(1)`

​					如果共享对象时**保存字符串值**的而字符串对象，那么验操作的复杂度`O(N)`

​					如果共享对象是**保存了多个值(或者对象**)，比如列表对象、哈希对象，那么验证操作的复杂度`O(N^2)`

​		 所以，虽然共享更加复制的对象可以节约更多的内存，但是受到CPU的限制，`Redis`只对包含**整数值的字符串对象**进行共享。

### 四、对象的空转时长

​		除了前面介绍的`type`、`encoding`、`ptr`、`refcount`四个属性之外，`redisObject`结构包含最后一个属性`lru`属性，，**记录着对象最后一次被命令程序访问的时间**：

​		![image-20200918132054642](.\imges\image-20200918132054642.png)

​		利用`object idletime`命令可以打印出给定键的空转时长，这一空转时长就是通过**`当前时间减去键的值对象的 lru 时间计算得出的`**：

![image-20200918132323178](.\imges\image-20200918132323178.png)![image-20200918132404129](.\imges\image-20200918132404129.png)

**注意：** 该命令的实现是特殊，因为**该命令在访问键的值对象时，是不会修改值对象的`lru`**

​			另外，键的空转时长**还有一个作用**，如果服务器开启了`maxmemory`选项，并且服务器用于回收内存的算法`volatile-lru`或者`allkeys-lru`，那么当服务器占用的内存超过了`maxmemory`选项设置的上限值时，那么**空转时长较高**的那部分键会**优先被服务器释放**，从而达到释放内存。
​	配置文件的`maxmemory`选项和`maxmemory-policy`选项的说明有更多的介绍信息。

### 五、总结

![image-20200918133347745](.\imges\image-20200918133347745.png)