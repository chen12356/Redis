### 一、服务器

#### 1、命令请求的执行流程

​	一个命令请求**从发送到获得回复**的过程中，客户端和服务器需要完成**一系列操作**。比如：

![image-20201027110605151](.\imges\image-20201027110605151.png)

##### 1.1  发送命令请求

​	`Redis`服务器的命令请求来自`Redis`客户端，当用户在客户端中**键入一个命令**请求时，客户端会将这个命令**请求转换成协议格式**，然后通过**连接到服务器的套接字**，将**协议格式的命令请求发送给服务器，**如下图：

![image-20201027105407454](.\imges\image-20201027105407454.png)

##### 1.2 读取命令请求

​	当客户端与服务器之间的连接套接字**因为  客户端的写入而变得可读时**，服务器将调用命令请求处理器来执行以下操作：

![image-20201027140134990](.\imges\image-20201027140134990.png)

![image-20201027140224305](.\imges\image-20201027140224305.png)

##### 1.3 命令执行器（1）：查找命令实现

​	命令执行器：**首先**需要根据客户端状态的`argv[0]参数`，在命令表中**查找参数所指定的命令**，并将找到的**命令保存到客户端状态的`cmd`属性**里面。

​	命令表是一个字典，**字典的键**是一个个**命令名字**，比如`set、get、del`等；而**字典的值**则是一个个**`redisCommand`结构**，每个`redisCommand`结构记录了一个`Redis`命令的实现信息

![image-20201027141243476](.\imges\image-20201027141243476.png)

![image-20201027141259858](.\imges\image-20201027141259858.png)

![image-20201027141331929](.\imges\image-20201027141331929.png)

![image-20201027141404597](.\imges\image-20201027141404597.png)

![image-20201027141431642](.\imges\image-20201027141431642.png)

![image-20201027141702050](.\imges\image-20201027141702050.png)

##### 1.4  命令执行器（2）：执行预备操作

​	此时，服务器将命令**所需的命令实现函数**（保存在客户端状态的cmd属性）、**参数**（保存在客户端状态的argv属性）、**参数个数**（保存在客户端状态的argc属性），但是在命令真正执行之前还有预备工作，为了确保能够准确、顺利执行：

+ 检查客户端状态的`cmd指针是否指向NULL`，是的话，说明用户输入的命令名字找不到命令实现函数，返回一个错误
+ 检查命令`请求的参数个数是否正确`。比如`redisCommand`结构的`arity`属性的值为 -3 ，那么用户输入的命令参数必须大于等于 3 个才行。
+ 检查`是否通过身份验证`，未通过身份验证的只能执行`AUTH`命令
+ 检查服务器`是否开启了 maxmemory功能`， 打开了，那么会执行命令之前检查内存占用，看情况进行内存回收，保证以下命令正常运行。

![image-20201105151117856](.\imges\image-20201105151117856.png)

##### 1.5 命令执行器(3)：调用命令实现函数

​	前面的操作已经把执行命令的实现函数保存到了客户端状态的`cmd`属性中，对应的参数和参数个数也是保存客户端的`argv`里面，,

```
// client 是这客户端状态的指针
client -> cmd -> proc(client);
		  		 proc指向的是该命令的实现函数
```

![image-20201105151615763](.\imges\image-20201105151615763.png)

![image-20201105152036232](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201105152036232.png)

##### 1.6 命令执行器（4）：执行后续工作

![image-20201105152236583](.\imges\image-20201105152236583.png)

##### 1.7 将命令回复发送给客户端

![image-20201105152427856](.\imges\image-20201105152427856.png)

##### 1.8 客户端接收并打印命令回复

![image-20201105152558134](.\imges\image-20201105152558134.png)

#### 2. `serverCron`函数

​	服务器会在 `每隔 100ms` 执行一次 `serverCron函数`，它负责管理服务器资源，并保持服务器自身的良好运转。下面会介绍该函数负责部分：

##### 2.1 更新服务器时间缓存

![image-20201105153125355](.\imges\image-20201105153125355.png)![image-20201105153014211](.\imges\image-20201105153014211.png)

##### 2.2 更新`LRU` 时钟

 	服务器状态中的 `lruclock` 属性保存了服务器的`LRU时钟`，这个时间和上面介绍的`unixtime和mstime属性一样`，都是服务器时间缓存的一种：
![image-20201105153911482](.\imges\image-20201105153911482.png)

例子：![image-20201105154126598](.\imges\image-20201105154126598.png)

##### 2.3 更新服务器每秒执行命令次数

​	查看 服务器在最近的 1秒钟内，处理了大概多少个命令：

![image-20201105154415343](.\imges\image-20201105154415343.png)

##### 2.4 更新服务器内存峰值记录

​	服务器状态中： **`stat_peak_memory`属性**记录服务器的内存峰值大小；每次 `severCron 函数`执行时，会检查服务器当前使用的内存数量，并于该属性保存的值作比较，如果该属性值要小，那么程序会把该属性的值改成内存使用数量，

##### ![image-20201105154857480](.\imges\image-20201105154857480.png)2.5  处理 `SIGTERM`信号

![image-20201105155026047](.\imges\image-20201105155026047.png)

![image-20201105155313015](.\imges\image-20201105155313015.png)

**拦截 `sigterm`信号情况**：服务器在关闭自身之前会进行`RDB`持久化操作，如果服务器一接收到`sigterm`信号就立即关闭的话，那么它就无法进行持久化操作了。

##### 2.6 管理客户端资源

​	`severCron`函数在执行前都会**调用 `clientCron`函数**，该函数会一定数量的客户端进行**两个检查**：

+ **检查客户端和服务器之间连接是否超时**，如果长时间客户端没有任何活动，那么程序会释放该客户端；
+ **检查客户端上一次执行命令请求之后的输入缓冲区大小是否超过一定的长度**，那么程序会释放当前的输出缓冲区，另外重新创建一个默认大小的输入缓冲区，防止客户端输入缓冲区浪费内存；

##### 2.7 管理数据库资源

​	`serverCron`函数每次执行也会**调用 `databasesCron`函数**，该函数会对服务器的**部分数据库进行检查，是删除过期的键**，并在有需要的时候，也会对字典进行收缩操作。在 字典介绍中，有介绍收缩操作。

##### 2.8  执行被延迟的 `bgrewriteaof`

![image-20201105160518028](.\imges\image-20201105160518028.png)

![image-20201105160611970](.\imges\image-20201105160611970.png)

##### 2.9 将`AOF`缓冲区内容 写入`AOF`文件

![image-20201105160919589](.\imges\image-20201105160919589.png)

##### 2.10 关闭异步客户端

![image-20201105160934579](.\imges\image-20201105160934579.png)

##### 2.11 增加`cronloops`计数器的值

![image-20201105161014790](.\imges\image-20201105161014790.png)

![image-20201105161037131](.\imges\image-20201105161037131.png)

